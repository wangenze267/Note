import{_ as e,c as t,o,a as r}from"./app.f25832bc.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"响应式2.0与3.0的对比","slug":"响应式2-0与3-0的对比","link":"#响应式2-0与3-0的对比","children":[]}],"relativePath":"fe_advance/Vue源码解析/Vue2源码解析/06.响应式2.0和3.0的对比.md"}'),_={name:"fe_advance/Vue源码解析/Vue2源码解析/06.响应式2.0和3.0的对比.md"},a=r('<h2 id="响应式2-0与3-0的对比" tabindex="-1">响应式2.0与3.0的对比 <a class="header-anchor" href="#响应式2-0与3-0的对比" aria-hidden="true">#</a></h2><p>在Vue2中，是用的 <code>Object.defineProperty</code>，在Vue3中，则是用的<code>proxy</code>；</p><p>先说 <strong>2.0</strong>：</p><ol><li>2.0 需要对每个属性进行监听，对 data 的属性是遍历 + 递归为每个属性设置 getter 和 setter</li><li>2.0 数组添加元素和长度的变化无法监视到采用的是<code>this.$set(obj,index,value)</code> 的方法</li><li>对象的添加值和删除值，<code>Object.defineProperty</code> 无法观测，采用的是 <code>this.$set(obj,key,value)</code> 的方法</li></ol><p>再说 <strong>3.0</strong>：</p><ol><li><p>弥补了上方所说的 2.0 中包含的 <strong>缺点</strong></p></li><li><p>采用了 <strong>惰性监听</strong>，初始化的时候，不再创建 Observer，而是会在用到的时候去监听，效率更高。</p></li></ol>',6),s=[a];function c(n,d,i,l,p,u){return o(),t("div",null,s)}const g=e(_,[["render",c]]);export{f as __pageData,g as default};
