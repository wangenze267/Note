import{_ as s,c as n,o as l,a}from"./app.8699f6ff.js";const C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"运行时 + 编译时","slug":"运行时-编译时","link":"#运行时-编译时","children":[{"level":3,"title":"初次渲染","slug":"初次渲染","link":"#初次渲染","children":[]},{"level":3,"title":"更新渲染","slug":"更新渲染","link":"#更新渲染","children":[]}]}],"relativePath":"fe_advance/Vue源码解析/Vue3源码解析/01.基本概念/09.运行时+编译时.md"}'),p={name:"fe_advance/Vue源码解析/Vue3源码解析/01.基本概念/09.运行时+编译时.md"},o=a(`<h2 id="运行时-编译时" tabindex="-1">运行时 + 编译时 <a class="header-anchor" href="#运行时-编译时" aria-hidden="true">#</a></h2><p>前面两小节我们已经分别了解了 <strong>运行时</strong> 和 <strong>编译时</strong> ，同时我们也知道了：<strong>vue是一个 运行时+编译时</strong> 的框架！</p><blockquote><p><code>vue </code>通过 <code>comliler</code> 解析 <code>html</code> 模板，生成 <code>render</code> 函数， 然后通过 <code>runtime</code> 解析 <code>render</code>， 从而挂载真实 <code>dom</code></p></blockquote><p>那么看到这里可能有些同学就会有疑惑了，既然 **compiler 可以直接解析 html 模板，**那么为什么还要生成 render 函数， 然后再去进行渲染呢？ 为什么不直接利用 compiler 进行渲染呢？</p><p>即： <strong>为什么 vue 要设计成一个 运行时 + 编译时的框架呢？</strong></p><p>那么想要理清楚这个问题，我们就需要知道 <strong>dom 渲染是如何进行的</strong></p><p>对于 <code>dom </code>渲染而言， 可以被分为两个部分：</p><ol><li><strong>初次渲染</strong>，我们把它叫做 <strong>挂载</strong></li><li><strong>更新渲染</strong>，我们可以把它叫做 <strong>打补丁</strong></li></ol><h3 id="初次渲染" tabindex="-1">初次渲染 <a class="header-anchor" href="#初次渲染" aria-hidden="true">#</a></h3><p>当初始 <code>div</code> 的 <code>inner HTML</code> 为空时</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">id</span><span style="color:#89DDFF;"> = </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">app</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们在该 <code>div</code> 中渲染如下节点：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样的一次渲染，就是 <strong>初次渲染</strong>。在这样的一次渲染中，我们会生成一个<code>ul</code>标签，同时生成三个<code>li</code>标签，并且把他们挂载到<code>div</code>中。</p><h3 id="更新渲染" tabindex="-1">更新渲染 <a class="header-anchor" href="#更新渲染" aria-hidden="true">#</a></h3><p>那么此时如果 <code>ul</code>标签的内容发成了变化：</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">3</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">1</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">2</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">li</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">ul</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>li - 3</code>上升到了第一位，那么此时可以想一下：<strong>我们期望浏览器如何来更新这次渲染呢？</strong></p><p>浏览器更新这次渲染无非有两种方式：</p><ol><li>删除原有的所有节点，重新渲染新的节点</li><li>删除原位置的<code>li - 3</code>，在新位置插入<code>li - 3</code></li></ol><p>那么这两种方式哪一种更好呢？那么我们来分析一下：</p><ol><li>首先对于第一种方式而言：它的好处在于不需要进行任何的比对，需要执行6次（删除3次，重新渲染3 次）<code>dom</code>处理即可。</li><li>对于第二种方式而言，在逻辑上相对比较复杂。他需要分成两步来做： <ol><li>对比 <strong>旧节点</strong> 和 <strong>新节点</strong> 之间的差异</li><li>根据差异，删除一个 <strong>旧节点</strong>，增加一个 <strong>新节点</strong></li></ol></li></ol><p>根据以上分析，我们可以知道：</p><ol><li>第一种方式：会涉及更多的<code>dom</code>操作</li><li>第二种方式：会涉及到<code>js</code>计算 + 少量的 <code>dom</code>操作</li></ol><p>那么这两种方式哪一种更快呢？我们来试验一下：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// time.js    </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 相同数量的 dom 操作 和 js 计算操作 哪一个更快</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> length </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10000</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 增加一万个 dom 节点，查看耗时</span></span>
<span class="line"><span style="color:#A6ACCD;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">time</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">element</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> length</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">div</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">createElement</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">body</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">appendChild</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">div</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeEnd</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">element</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 增加一万个 js 对象， 查看耗时</span></span>
<span class="line"><span style="color:#A6ACCD;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">time</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> divList </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> length</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">ele</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">            type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">        </span><span style="color:#A6ACCD;">divList</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">push</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">ele</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">timeEnd</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">js</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>从结果可以看出，<code>dom</code>的操作要比<code>js</code>的操作耗时多得多(<s>demo中为10倍的差距</s>)，即：<strong>dom 操作比 js 更加耗费性能</strong>。</p><p>那么根据这样一个结论，回到刚刚我们所说的场景中：</p><blockquote><ol><li>首先对于第一种方式而言：它的好处在于不需要进行任何的比对，需要执行6次（删除3次，重新渲染3 次）<code>dom</code>处理即可。</li><li>对于第二种方式而言，在逻辑上相对比较复杂。他需要分成两步来做： <ol><li>对比 <strong>旧节点</strong> 和 <strong>新节点</strong> 之间的差异</li><li>根据差异，删除一个 <strong>旧节点</strong>，增加一个 <strong>新节点</strong></li></ol></li></ol></blockquote><p>根据结论可知： <strong>方式一会比方式二更加消耗性能（即：性能更差）</strong></p><p>得出这样的结论之后，我们回过头再去看最初的问题：<strong>为什么<code>vue</code>要设计一个运行时+编译时的框架呢？</strong></p><p>答：</p><ol><li>针对于 <strong>纯运行时</strong> 而言：因为不存在编译器，所以我们只能提供一个复杂的 <code>js</code>对象。</li><li>针对于 <strong>纯编译时</strong> 而言：因为缺少运行时，所以它只能把分析差异的操作，放到 <strong>编译时</strong>进行，同样因为省略了运行时，所以速度可能会更快。但是这种方式将损失灵活性（具体可查看第六章虚拟 DOM，也有<code>vue</code>官方提供的<a href="https://cn.vuejs.org/guide/extras/render-function.html#render-functions-jsx" target="_blank" rel="noreferrer">示例</a>）。比如 <a href="https://www.sveltejs.cn/" target="_blank" rel="noreferrer">svelte</a>，它就是一个纯编译时的框架，但是它的实际运行速度可能达不到理论上的速度。</li><li><strong>运行时 + 编译时</strong>：比如 <code>vue</code> 和 <code>react</code> 都是通过这种方式来进行构建的，使其可以在保持灵活性的基础上，尽量的进行性能优化，从而达到一种平衡。</li></ol>`,33),e=[o];function t(r,c,i,D,F,y){return l(),n("div",null,e)}const A=s(p,[["render",t]]);export{C as __pageData,A as default};
