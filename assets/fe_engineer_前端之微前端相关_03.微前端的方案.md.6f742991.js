import{_ as e,c as t,o as i,a}from"./app.dc73b7df.js";const h=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"微前端的方案有哪些？","slug":"微前端的方案有哪些","link":"#微前端的方案有哪些","children":[]}],"relativePath":"fe_engineer/前端之微前端相关/03.微前端的方案.md"}'),r={name:"fe_engineer/前端之微前端相关/03.微前端的方案.md"},n=a('<h3 id="微前端的方案有哪些" tabindex="-1">微前端的方案有哪些？ <a class="header-anchor" href="#微前端的方案有哪些" aria-hidden="true">#</a></h3><p>在实际开发项目的过程中，我们主要分为 MPA 和 SPA 来讨论。</p><p>对于 SPA 开发模式的项目，可以采用以下方案进行改造：</p><ul><li>基于 NPM 包的微前端：将微应用打包成独立的 NPM 包，然后在主应用中安装和使用；</li><li>基于代码分割的微前端：在主应用中使用懒加载技术，在运行时动态加载不同的微应用；</li><li>基于 Web Components 的微前端：将微应用封装成自定义组件，在主应用中注册使用；</li><li>基于 Module Federation 的微前端：借助 Webpack 5 的 Module Federation 实现微前端；</li><li>基于动态 Script 的微前端：在主应用中动态切换微应用的 Script 脚本来实现微前端；</li><li>基于 iframe 的微前端：在主应用中使用 iframe 标签来加载不同的微应用；</li><li>基于框架（JavaScript SDK）的微前端：使用 single-spa、qiankun 等通用框架。</li></ul><p>其中基于 NPM 包、代码分割、 传统 Web Components 和构建工具的微前端方案，无法使得微应用具备运行时的动态化能力。</p><p>而基于动态 Script 、iframe 和框架的微前端方案则可以在运行时做到动态化。</p><p>当然，在实际使用中，一些方案还可以组合使用。</p><p>对于 MPA 的开发模式：</p><p>前端应用具备天然拆分成小型应用的特性，可以部署在各自服务下，在主应用中通过服务端返回的路由，来切换渲染不同的微应用。</p><p>但是，如何实现微应用之间的通信和数据共享是一个值得考虑的重要问题。</p><blockquote><p>温馨提示：MPA 模式下后端的技术栈方案非常多，可以是单个服务框架，可以是多个不同的服务框架，还可以是微服务框架。不同路由的 HTTP 请求将被分发到对应的服务上，这些服务可能是 Niginx 反向代理后的服务、Nginx 部署的静态资源服务、CDN 服务以及对象存储服务等。</p></blockquote><p>MPA 的模式设计微前端可以使前后端采用不同的技术框架来实现，从而解决更加宽泛的团队协作问题。同时这种方式对于整体框架的设计更加灵活多变，可以很好解决不同技术栈之间因为差异大而难以进行迁移和兼容的问题，是微前端架构中采用最多且也是最容易实现的方案。</p><p><strong>但是目前社区常见的微前端框架基本上都是倾向于使用 SPA 模式进行开发，主要解决的是前端应用自身的解耦问题，这个解耦的过程本身可能不涉及服务端的任何更改。</strong></p><blockquote><p>学习资料：<a href="https://juejin.cn/book/7258893482318626868" target="_blank" rel="noreferrer">深入浅出微前端</a></p></blockquote>',14),o=[n];function p(l,_,c,s,d,u){return i(),t("div",null,o)}const P=e(r,[["render",p]]);export{h as __pageData,P as default};
