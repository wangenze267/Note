import{_ as n,c as e,o as s,a}from"./app.245e0f08.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"痛点","slug":"痛点","link":"#痛点","children":[{"level":3,"title":"代码复用","slug":"代码复用","link":"#代码复用","children":[]},{"level":3,"title":"基建复用","slug":"基建复用","link":"#基建复用","children":[]},{"level":3,"title":"版本管理","slug":"版本管理","link":"#版本管理","children":[]}]},{"level":2,"title":"该说说 Monorepo 了","slug":"该说说-monorepo-了","link":"#该说说-monorepo-了","children":[]},{"level":2,"title":"Monorepo 带来的好处","slug":"monorepo-带来的好处","link":"#monorepo-带来的好处","children":[{"level":3,"title":"简化仓库组织","slug":"简化仓库组织","link":"#简化仓库组织","children":[]},{"level":3,"title":"减少依赖","slug":"减少依赖","link":"#减少依赖","children":[]},{"level":3,"title":"跨域开发","slug":"跨域开发","link":"#跨域开发","children":[]},{"level":3,"title":"便于管理","slug":"便于管理","link":"#便于管理","children":[]},{"level":3,"title":"落地","slug":"落地","link":"#落地","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"fe_engineer/前端工程化相关/05.Monorepo.md"}'),p={name:"fe_engineer/前端工程化相关/05.Monorepo.md"},l=a(`<h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-hidden="true">#</a></h3><p>在了解 Monorepo 之前，先来了解一下 Multirepo 的概念。</p><p>Multirepo 风格，即每个项目对应着一个单独的仓库。在其内部遵循着 <strong>模块化</strong> 与 <strong>组件化</strong> 的原则拆分代码，尽量不在一个项目中糅合太多东西，根据不同需求划分多个仓库，仓库间保持独立，每个项目都可以独立开发，独立部署，且不受其他项目影响。</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">vue-app</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">vue1-app</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">vue2-app</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">... # 另外多个仓库</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="痛点" tabindex="-1">痛点 <a class="header-anchor" href="#痛点" aria-hidden="true">#</a></h2><p>时间一长，多个仓库共同管理的弊端就会暴露出来。</p><h3 id="代码复用" tabindex="-1">代码复用 <a class="header-anchor" href="#代码复用" aria-hidden="true">#</a></h3><p>我们一定都干过这个事情，就是在维护多个项目的时候遇到相同场景或者相同业务逻辑的时候，我们会将公共逻辑复制多份，去应用到多个项目中。</p><p>优点： <strong>简单无脑</strong> 缺点：<strong>维护成本非常高</strong></p><p>可能略微具备<strong>前端工程化</strong>知识的同学，会将公共逻辑进行抽取并将其封装成一个 npm包并发布，这样只需要在用到此逻辑的项目进行安装即可。</p><p>这样貌似解决了公共逻辑复用的问题，降低了维护成本（真的吗？？）</p><p>如果公共逻辑出现 Bug ，就要修复后重新发布 npm ，之后再次安装。</p><p>不同于正常 npm 包的正常开发迭代，这种常用的包在开发阶段很难保证不出 Bug ，且有些 Bug 的修复，仅需要改动一行代码，所以真的有必要重复这些步骤吗？</p><blockquote><p>发现 Bug ---&gt; 修复 Bug ---&gt; 发布 npm 包 ---&gt; 重新安装 npm 包 ---&gt;发现新 Bug</p></blockquote><p>这问题就是 Multirepo 的痛点，介于工作区的割裂，导致复用代码的成本剧增，开发调试的流程繁琐，在基础库改动频繁的情况下，会让开发人员的情绪暴躁，开发体验很差。</p><h3 id="基建复用" tabindex="-1">基建复用 <a class="header-anchor" href="#基建复用" aria-hidden="true">#</a></h3><p>与上述逻辑复用的情况相同，这个问题在项目基建中也一样存在。每个项目都会拥有自己的环境配置、构建、打包、CI/CD 等，这些代码块肯定也会存在很多公共部分被复用的情况。</p><p>比如基于 rollup 编写一个脚本去用来打包工具库，而打包组件库也可以用到，只是相比于工具库，需要加一些样式处理的逻辑，但是不能因此认为两种情况的逻辑是完全不同的就将它们区分开来。</p><p>有时发布一个需求可能要同时发布多个项目，项目之间存在的构建、测试、打包、部署和发布的规范不统一，这样维护起来就更麻烦了。</p><h3 id="版本管理" tabindex="-1">版本管理 <a class="header-anchor" href="#版本管理" aria-hidden="true">#</a></h3><p>管理多个项目时，每次定义和更新版本号都是一件很麻烦的事情。</p><blockquote><p>确实，最近开源项目更新版本号打包每次都很烦躁</p></blockquote><p>初始的时候每个项目都是 <code>v1.0.0</code>，但是随着迭代速度的不同，就会变得参差不齐。</p><p>假如依赖的一个组件库或工具库发生大版本迭代，api 或配置参数发生出入，就会导致引用该版本的项目产生一连窜错误。</p><p>随着项目数量的增多，依赖更新不及时的情况很常见，导致查漏补缺的时间成本大大提高。</p><h2 id="该说说-monorepo-了" tabindex="-1">该说说 Monorepo 了 <a class="header-anchor" href="#该说说-monorepo-了" aria-hidden="true">#</a></h2><p>相比于上文提到的 Multirepo，另一种风格叫做 Monorepo。Monorepo 其实不是一个新概念，它在软件工程领域已有十多年历史。它把每个项目放到不同仓库中，每个项目对应一个单独仓库分散管理。</p><p>对于 Monorepo 而言，只是把多个项目根据预设场景组织到一起，它的粒度还是保持原有的划分。对于团队某个成员而言，他的关注点还是在其中一个项目中。</p><p>用下图可以直观的看一下大致区别：</p><p><img src="https://img.wangez.site/img/Monorepo.png" alt=""></p><p>Monorepo 的项目结构一般根据以下目录划分：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">project</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ util</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ components</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ lib</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ ... # 另外多个仓库</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="monorepo-带来的好处" tabindex="-1">Monorepo 带来的好处 <a class="header-anchor" href="#monorepo-带来的好处" aria-hidden="true">#</a></h2><h3 id="简化仓库组织" tabindex="-1">简化仓库组织 <a class="header-anchor" href="#简化仓库组织" aria-hidden="true">#</a></h3><p>随着业务需求的不断迭代，项目越来越复杂，就要在后期对项目进行拆分，使用 Monorepo 模式管理项目，可以有效简化项目结构组织。因为很多拆分都不是非必要原因的拆分，只是因为代码量多。</p><h3 id="减少依赖" tabindex="-1">减少依赖 <a class="header-anchor" href="#减少依赖" aria-hidden="true">#</a></h3><p>对于 <code>npm install</code> 这个烙印在前端骨子里的东西，带来了庞大的 <code>node_modules</code> ，但是许多项目所依赖的 npm 模块都是相同的。</p><p>使用 Monorepo 模式管理这些项目，可以把依赖提取出来，可以消除重复安装依赖所带来的影响。</p><h3 id="跨域开发" tabindex="-1">跨域开发 <a class="header-anchor" href="#跨域开发" aria-hidden="true">#</a></h3><p>如果同时对多个 npm 模块进行迭代，在调试的时候就需要不断的执行 <code>npm link</code>，使用 Monorepo 模式管理，就可以直接在本地进行联调，有效提高开发效率。</p><h3 id="便于管理" tabindex="-1">便于管理 <a class="header-anchor" href="#便于管理" aria-hidden="true">#</a></h3><p>对于一些大型项目或开源项目，多个仓库意味着要在多个地方处理 Issue 和 PR，所以更倾向于在一个仓库对其进行统一管理。</p><h3 id="落地" tabindex="-1">落地 <a class="header-anchor" href="#落地" aria-hidden="true">#</a></h3><p>如果还没接触过 Monorepo 管理模式的项目，会产生一个疑惑：</p><blockquote><p>我是直接把多个项目直接合并成上述项目结构就完事了吗？</p></blockquote><p>当然不是。</p><p>在实际场景去落地 Monorepo 模式，是需要有一套完整的工程体系支撑的，不是仅修改项目结构，将代码放到一起就完事，还需要考虑项目间的依赖分析、依赖安装、依赖卸载、构建流程、测试流程、打包流程、部署流程、发布流程等诸多工程环节，同时还要考虑项目规模到达一定程度后的性能问题，比如其中某流程的执行时间，在实现全面工程化的同时也需要兼顾性能问题。</p><p>社区为我们提供了一些较为成熟的方案，让我们可以在此基础上来构建一套较完善的，适合我们的 Monorepo 工程化工具。</p><p>比如其中的 <code>lerna</code> ，封装了依赖安装（卸载）、脚本批量执行等基本功能，但是它无法提供一套完整的构建、测试、打包、部署和发布功能的工具链，整体功能较弱，往往我们需要在其的基础上去封装，来提供更全面的工程支持能力。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p>从 Multirepo 的角度来看，每个团队拥有自己的仓库，可用自己擅长的工具与工作流程。技术的多元化能促使各个团队尽可能地提升自己的效率，当然 Multirepo 的代价在于增加很多沟通成本。若在其中一个项目发现 Bug ，就必须修复后再次发布到 npm 并再次安装，然后再回到原来的项目中继续工作。</p><p>在不同仓库间，不仅需处理不同代码与工具，甚至是不同工作流程，甚至在无权限的情况下只能低声下气求人。</p><p>从 Monorepo 的角度来看，让不同团队走自己的路并不见得能提高生产力。虽然有些团队可能会找到自己最佳的工作方式，但他们的收益也会被其他团队不好的工作方式抵消。</p><p>相反，严格统一的管理更能提升开发效率，团队每个成员都可修改任何东西。</p><blockquote><p>即，将鸡蛋都放到了同一个篮子里，因此也可以更好的去照顾鸡蛋。</p></blockquote><p>若最终选择 Monorepo ，那主要的挑战自然是随着项目发展，其规模会变得很庞大，因此需使用很多工具应对这些挑战。</p><blockquote><p>参考资料：<a href="https://juejin.cn/book/7034689774719860739" target="_blank" rel="noreferrer">从零到一落地前端工程化</a></p></blockquote>`,57),o=[l];function r(i,c,t,d,h,u){return s(),e("div",null,o)}const g=n(p,[["render",r]]);export{m as __pageData,g as default};
