import{_ as n,c as s,o as a,a as e}from"./app.1e966a8f.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"痛点","slug":"痛点","link":"#痛点","children":[{"level":3,"title":"代码复用","slug":"代码复用","link":"#代码复用","children":[]},{"level":3,"title":"基建复用","slug":"基建复用","link":"#基建复用","children":[]},{"level":3,"title":"版本管理","slug":"版本管理","link":"#版本管理","children":[]}]},{"level":2,"title":"该说说 Monorepo 了","slug":"该说说-monorepo-了","link":"#该说说-monorepo-了","children":[]},{"level":2,"title":"Monorepo 带来的好处","slug":"monorepo-带来的好处","link":"#monorepo-带来的好处","children":[{"level":3,"title":"简化仓库组织","slug":"简化仓库组织","link":"#简化仓库组织","children":[]},{"level":3,"title":"减少依赖","slug":"减少依赖","link":"#减少依赖","children":[]},{"level":3,"title":"跨域开发","slug":"跨域开发","link":"#跨域开发","children":[]},{"level":3,"title":"便于管理","slug":"便于管理","link":"#便于管理","children":[]}]}],"relativePath":"fe_engineer/前端工程化相关/05.Monorepo介绍.md"}'),p={name:"fe_engineer/前端工程化相关/05.Monorepo介绍.md"},l=e(`<h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-hidden="true">#</a></h3><p>在了解 Monorepo 之前，先来了解一下 Multirepo 的概念。</p><p>Multirepo 风格，即每个项目对应着一个单独的仓库。在其内部遵循着 <strong>模块化</strong> 与 <strong>组件化</strong> 的原则拆分代码，尽量不在一个项目中糅合太多东西，根据不同需求划分多个仓库，仓库间保持独立，每个项目都可以独立开发，独立部署，且不受其他项目影响。</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">vue-app</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">vue1-app</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">vue2-app</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">... # 另外多个仓库</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="痛点" tabindex="-1">痛点 <a class="header-anchor" href="#痛点" aria-hidden="true">#</a></h2><p>时间一长，多个仓库共同管理的弊端就会暴露出来。</p><h3 id="代码复用" tabindex="-1">代码复用 <a class="header-anchor" href="#代码复用" aria-hidden="true">#</a></h3><p>我们一定都干过这个事情，就是在维护多个项目的时候遇到相同场景或者相同业务逻辑的时候，我们会将公共逻辑复制多份，去应用到多个项目中。</p><p>优点： <strong>简单无脑</strong> 缺点：<strong>维护成本非常高</strong></p><p>可能略微具备<strong>前端工程化</strong>知识的同学，会将公共逻辑进行抽取并将其封装成一个 npm包并发布，这样只需要在用到此逻辑的项目进行安装即可。</p><p>这样貌似解决了公共逻辑复用的问题，降低了维护成本（真的吗？？）</p><p>如果公共逻辑出现 Bug ，就要修复后重新发布 npm ，之后再次安装。</p><p>不同于正常 npm 包的正常开发迭代，这种常用的包在开发阶段很难保证不出 Bug ，且有些 Bug 的修复，仅需要改动一行代码，所以真的有必要重复这些步骤吗？</p><blockquote><p>发现 Bug ---&gt; 修复 Bug ---&gt; 发布 npm 包 ---&gt; 重新安装 npm 包 ---&gt;发现新 Bug</p></blockquote><p>这问题就是 Multirepo 的痛点，介于工作区的割裂，导致复用代码的成本剧增，开发调试的流程繁琐，在基础库改动频繁的情况下，会让开发人员的情绪暴躁，开发体验很差。</p><h3 id="基建复用" tabindex="-1">基建复用 <a class="header-anchor" href="#基建复用" aria-hidden="true">#</a></h3><p>与上述逻辑复用的情况相同，这个问题在项目基建中也一样存在。每个项目都会拥有自己的环境配置、构建、打包、CI/CD 等，这些代码块肯定也会存在很多公共部分被复用的情况。</p><p>比如基于 rollup 编写一个脚本去用来打包工具库，而打包组件库也可以用到，只是相比于工具库，需要加一些样式处理的逻辑，但是不能因此认为两种情况的逻辑是完全不同的就将它们区分开来。</p><p>有时发布一个需求可能要同时发布多个项目，项目之间存在的构建、测试、打包、部署和发布的规范不统一，这样维护起来就更麻烦了。</p><h3 id="版本管理" tabindex="-1">版本管理 <a class="header-anchor" href="#版本管理" aria-hidden="true">#</a></h3><p>管理多个项目时，每次定义和更新版本号都是一件很麻烦的事情。</p><blockquote><p>确实，最近开源项目更新版本号打包每次都很烦躁</p></blockquote><p>初始的时候每个项目都是 <code>v1.0.0</code>，但是随着迭代速度的不同，就会变得参差不齐。</p><p>假如依赖的一个组件库或工具库发生大版本迭代，api 或配置参数发生出入，就会导致引用该版本的项目产生一连窜错误。</p><p>随着项目数量的增多，依赖更新不及时的情况很常见，导致查漏补缺的时间成本大大提高。</p><h2 id="该说说-monorepo-了" tabindex="-1">该说说 Monorepo 了 <a class="header-anchor" href="#该说说-monorepo-了" aria-hidden="true">#</a></h2><p>相比于上文提到的 Multirepo，另一种风格叫做 Monorepo。Monorepo 其实不是一个新概念，它在软件工程领域已有十多年历史。它把每个项目放到不同仓库中，每个项目对应一个单独仓库分散管理。</p><p>对于 Monorepo 而言，只是把多个项目根据预设场景组织到一起，它的粒度还是保持原有的划分。对于团队某个成员而言，他的关注点还是在其中一个项目中。</p><p>用下图可以直观的看一下大致区别：</p><p><img src="https://img.wangez.site/img/Monorepo.png" alt=""></p><p>Monorepo 的项目结构一般根据以下目录划分：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">project</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ util</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ components</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">├─ lib</span></span>
<span class="line"><span style="color:#A6ACCD;">│  ├─ src</span></span>
<span class="line"><span style="color:#A6ACCD;">│  └─ package.json</span></span>
<span class="line"><span style="color:#A6ACCD;">└─ ... # 另外多个仓库</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="monorepo-带来的好处" tabindex="-1">Monorepo 带来的好处 <a class="header-anchor" href="#monorepo-带来的好处" aria-hidden="true">#</a></h2><h3 id="简化仓库组织" tabindex="-1">简化仓库组织 <a class="header-anchor" href="#简化仓库组织" aria-hidden="true">#</a></h3><p>随着业务需求的不断迭代，项目越来越复杂，就要在后期对项目进行拆分，使用 Monorepo 模式管理项目，可以有效简化项目结构组织。因为很多拆分都不是非必要原因的拆分，只是因为代码量多。</p><h3 id="减少依赖" tabindex="-1">减少依赖 <a class="header-anchor" href="#减少依赖" aria-hidden="true">#</a></h3><p>对于 <code>npm install</code> 这个烙印在前端骨子里的东西，带来了庞大的 <code>node_modules</code> ，但是许多项目所依赖的 npm 模块都是相同的。</p><p>使用 Monorepo 模式管理这些项目，可以把依赖提取出来，可以消除重复安装依赖所带来的影响。</p><h3 id="跨域开发" tabindex="-1">跨域开发 <a class="header-anchor" href="#跨域开发" aria-hidden="true">#</a></h3><p>如果同时对多个 npm 模块进行迭代，在调试的时候就需要不断的执行 <code>npm link</code>，使用 Monorepo 模式管理，就可以直接在本地进行联调，有效提高开发效率。</p><h3 id="便于管理" tabindex="-1">便于管理 <a class="header-anchor" href="#便于管理" aria-hidden="true">#</a></h3><p>对于一些大型项目或开源项目，多个仓库意味着要在多个地方处理 Issue 和 PR，所以更倾向于在一个仓库对其进行统一管理。</p>`,42),r=[l];function o(i,c,t,d,h,u){return a(),s("div",null,r)}const C=n(p,[["render",o]]);export{m as __pageData,C as default};
