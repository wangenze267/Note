# 谈谈 Vue3 中模板编译做了哪些优化？

## PatchFlags 优化

Diff 算法无法避免新旧虚拟 Dom 中无用的比较操作，通过 patchFlags 来标记动态内容，可以实现快速 diff 算法

```html
<div>
    <h1>Hello Ned</h1>
    <span>{{ name }}</span>
</div>
```

这段代码经过模板编译后，会变成如下代码：


```javascript
const {
    createElementVNode: _createElementVNode,
    toDisplayString: _toDisplayString,
    createTextVNode: _createTextVNode,
    openBlock: _openBlock,
    createElementBlock: _createElementBlock,
} = vue
return function render(_ctx, _cache, $props, $setup, $data, $options) {
    return (
        _openBlock(),
        _createElementBlock("div", null, [
            _createElementVNode("h1", null, "Hello Ned"),
            _createTextVNode(),
            _createElementVNode(
                "span",
                null,
                _toDisplayString(_ctx.name),
                1 // Text文本
            )
        ])
    )
}
```

### 创建虚拟节点
生成的虚拟 Dom 是：

```javascript
{
    type: "div",
    __v_isVNode: true,
    children: [
        {type: 'h1', props: null, key: null, ...},
        {type: Symbol(), props: null, key: null, ...},
        {type: 'span', props: null, key: null, ...}
    ],
    dynamicChildren: [{type: 'span', children: _ctx.name, patchFlag: 1}]
}
```

此时生成的虚拟节点多出一个 dynamicChildren 属性。 这个就是 block 的作用，block 可以收集所有后代动态节点。 这样后续更新时可以直接跳过静态节点，实现靶向更新

### 动态标识

```javascript
export const enum PatchFlags {
    TEXT = 1, // 动态文本节点
    CLASS = 1 << 1, // 动态 class
    STYLE = 1 << 2, // 动态 style
    PROPS = 1 << 3, // 除了 class/style 动态属性
    FULL_PROPS = 1 << 4, // 有 key, 需要完整的 diff
    HYDRATE_EVENTS = 1 << 5, // 挂载过事件的
    STABLE_FRAGMENT = 1 << 6, // 稳定序列，子节点顺序不会发生变化
    KEYED_FRAGMENT = 1 << 7, // 子节点有 key 的 fragment
    UNKEYED_FRAGMENT = 1 << 8, // 子节点没有 key 的 fragment
    NEED_PATCH = 1 << 9, // 进行非 props 比较，ref 比较
    DYNAMIC_SLOTS = 1 << 10, // 动态插槽
    DEV_ROOT_FRAGMENT = 1 << 11,
    HOISTED = -1, // 表示静态节点，内容变化，不比较子节点
    BAIL = -2 // 表示 diff 算法应该结束
}
```
