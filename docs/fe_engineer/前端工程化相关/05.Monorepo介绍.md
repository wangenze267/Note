### 背景

在了解 Monorepo 之前，先来了解一下 Multirepo 的概念。

Multirepo 风格，即每个项目对应着一个单独的仓库。在其内部遵循着 **模块化** 与 **组件化** 的原则拆分代码，尽量不在一个项目中糅合太多东西，根据不同需求划分多个仓库，仓库间保持独立，每个项目都可以独立开发，独立部署，且不受其他项目影响。

```
vue-app
├─ src
└─ package.json
vue1-app
├─ src
└─ package.json
vue2-app
├─ src
└─ package.json
... # 另外多个仓库

```

## 痛点

时间一长，多个仓库共同管理的弊端就会暴露出来。

### 代码复用

我们一定都干过这个事情，就是在维护多个项目的时候遇到相同场景或者相同业务逻辑的时候，我们会将公共逻辑复制多份，去应用到多个项目中。

优点： **简单无脑**      缺点：**维护成本非常高**

可能略微具备**前端工程化**知识的同学，会将公共逻辑进行抽取并将其封装成一个 npm包并发布，这样只需要在用到此逻辑的项目进行安装即可。

这样貌似解决了公共逻辑复用的问题，降低了维护成本（真的吗？？）

如果公共逻辑出现 Bug ，就要修复后重新发布 npm ，之后再次安装。

不同于正常 npm 包的正常开发迭代，这种常用的包在开发阶段很难保证不出 Bug ，且有些 Bug 的修复，仅需要改动一行代码，所以真的有必要重复这些步骤吗？

> 发现 Bug ---> 修复 Bug ---> 发布 npm 包 ---> 重新安装 npm 包 --->发现新 Bug

这问题就是 Multirepo 的痛点，介于工作区的割裂，导致复用代码的成本剧增，开发调试的流程繁琐，在基础库改动频繁的情况下，会让开发人员的情绪暴躁，开发体验很差。

### 基建复用

与上述逻辑复用的情况相同，这个问题在项目基建中也一样存在。每个项目都会拥有自己的环境配置、构建、打包、CI/CD 等，这些代码块肯定也会存在很多公共部分被复用的情况。

比如基于 rollup 编写一个脚本去用来打包工具库，而打包组件库也可以用到，只是相比于工具库，需要加一些样式处理的逻辑，但是不能因此认为两种情况的逻辑是完全不同的就将它们区分开来。

有时发布一个需求可能要同时发布多个项目，项目之间存在的构建、测试、打包、部署和发布的规范不统一，这样维护起来就更麻烦了。

### 版本管理

管理多个项目时，每次定义和更新版本号都是一件很麻烦的事情。

> 确实，最近开源项目更新版本号打包每次都很烦躁

初始的时候每个项目都是 `v1.0.0`，但是随着迭代速度的不同，就会变得参差不齐。

假如依赖的一个组件库或工具库发生大版本迭代，api 或配置参数发生出入，就会导致引用该版本的项目产生一连窜错误。

随着项目数量的增多，依赖更新不及时的情况很常见，导致查漏补缺的时间成本大大提高。

## 该说说 Monorepo 了

相比于上文提到的  Multirepo，另一种风格叫做 Monorepo。Monorepo 其实不是一个新概念，它在软件工程领域已有十多年历史。它把每个项目放到不同仓库中，每个项目对应一个单独仓库分散管理。

对于 Monorepo 而言，只是把多个项目根据预设场景组织到一起，它的粒度还是保持原有的划分。对于团队某个成员而言，他的关注点还是在其中一个项目中。

用下图可以直观的看一下大致区别：

![](https://img.wangez.site/img/Monorepo.png)

Monorepo 的项目结构一般根据以下目录划分：

```
project
├─ util
│  ├─ src
│  └─ package.json
├─ components
│  ├─ src
│  └─ package.json
├─ lib
│  ├─ src
│  └─ package.json
└─ ... # 另外多个仓库
```

## Monorepo 带来的好处

### 简化仓库组织

随着业务需求的不断迭代，项目越来越复杂，就要在后期对项目进行拆分，使用 Monorepo 模式管理项目，可以有效简化项目结构组织。因为很多拆分都不是非必要原因的拆分，只是因为代码量多。

### 减少依赖

对于 `npm install` 这个烙印在前端骨子里的东西，带来了庞大的 `node_modules` ，但是许多项目所依赖的 npm 模块都是相同的。

使用 Monorepo 模式管理这些项目，可以把依赖提取出来，可以消除重复安装依赖所带来的影响。

### 跨域开发

如果同时对多个 npm 模块进行迭代，在调试的时候就需要不断的执行 `npm link`，使用 Monorepo 模式管理，就可以直接在本地进行联调，有效提高开发效率。

### 便于管理

对于一些大型项目或开源项目，多个仓库意味着要在多个地方处理 Issue 和 PR，所以更倾向于在一个仓库对其进行统一管理。